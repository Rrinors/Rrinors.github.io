<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CF1733 D2. Zero-One (Hard Version)</title>
    <url>/2022/09/20/CF1733D2/</url>
    <content><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>给定两个长度为 $n$ 的 $01$ 串 $s$ 和 $t$，可以进行任何多次操作：</p>
<ul>
<li>选择两个位置 $l$ 和 $r$（$l&lt;r$）。</li>
<li>将 $s$ 串 $l$ 和 $r$ 位置的数反转（即 $1$ 变为 $0$，$0$ 变为 $1$）。</li>
<li>如果 $r=l+1$，那么花费 $x$ 的代价，否则花费 $y$ 的代价。</li>
</ul>
<p>求将 $s$ 变为 $t$ 的最小代价，或者宣告其不可能。</p>
<h1 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h1><p>$5\leq n\leq5000$，$x,y\leq10^9$。</p>
<p>多组数据，但保证 $\sum n\leq5000$。</p>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>首先，本题需要把 $\mathrm s[i]\neq \mathrm t[i]$ 的所有下标 $i$ 进行两两匹配，然后使所有 $\mathrm s[i]= \mathrm t[i]$。</p>
<p>如果不能完成两两匹配，即不满足 $\mathrm s[i]= \mathrm t[i]$ 的下标个数为奇数，则不可能完成。</p>
<p>分 $x\geq y$ 和 $x&lt;y$ 两种情况讨论能完成的情况。</p>
<p>$x\geq y$：贪心地考虑，选择不相邻的两个下标进行两两匹配比选相邻的优，所以尽可能让匹配的下标错开。设有 $m$ 个需要匹配的下标，我们可以让 $i$ 和 $i+\frac m 2$ 匹配。除了直接两两匹配，我们还可以间接地进行匹配，即 $(i,j)\rightarrow(i,k)(j,k)$，$(u,v)$代表 $u$、$v$ 以 $y$ 的代价进行一次操作。间接匹配的前提是存在一个 $k$ 使得 $k$ 与 $i$ 和 $j$ 都不相邻。 </p>
<p>$x&lt;y$：一个不满足 $\mathrm s[i]= \mathrm t[i]$ 的下标要么以 $x$ 为代价消去，要么以 $y$ 为代价消去。可以考虑 $\mathrm{dp}$，设 $\mathrm{dp}[i][0/1]$ 为第 $i$ 个不满足 $\mathrm s[i]= \mathrm t[i]$ 的下标 $i$ 以 $y/x$ 为代价消去并使其之前的串满足最终条件（$s=t$）的总代价和。转移方程为：</p>
<ul>
<li>$\mathrm{dp}[i][1]=x*(\mathrm p[i-1]-\mathrm p[i-2])+\min(\mathrm{dp}[i-2][0],\mathrm{dp}[i-2][1])$</li>
<li>$\mathrm{dp}[i][0] = \min(\mathrm{dp}[i-1][0],\mathrm{dp}[i-1][1])+y*(i\mod2=0)$</li>
</ul>
<p>时间复杂度为 $O(n)$。</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> i64 inf = <span class="number">1E18</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, x, y;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; x &gt;&gt; y;</span><br><span class="line"></span><br><span class="line">    std::string s, t;</span><br><span class="line">    std::cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] != t[i]) p.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;0\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p.<span class="built_in">size</span>() &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &gt;= y) &#123;</span><br><span class="line">        i64 ans;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p.<span class="built_in">size</span>() == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[<span class="number">1</span>] == p[<span class="number">0</span>] + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">                    ans = x;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">3</span>) &#123;</span><br><span class="line">                    ans = x;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">4</span> &amp;&amp; p[<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                    ans = x;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ans = std::<span class="built_in">min</span>(x, <span class="number">2</span> * y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans = y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans = p.<span class="built_in">size</span>() / <span class="number">2</span> * y;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> m = p.<span class="built_in">size</span>();</span><br><span class="line">        std::vector&lt;std::array&lt;i64, 2&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="number">1ll</span> * x * (p[i - <span class="number">1</span>] - p[i - <span class="number">2</span>]) + std::<span class="built_in">min</span>(dp[i - <span class="number">2</span>][<span class="number">0</span>], dp[i - <span class="number">2</span>][<span class="number">1</span>]);</span><br><span class="line">            dp[i][<span class="number">0</span>] = std::<span class="built_in">min</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>]) + (i % <span class="number">2</span> == <span class="number">0</span> ? y : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; std::<span class="built_in">min</span>(dp[m][<span class="number">0</span>], dp[m][<span class="number">1</span>]) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    std::cin &gt;&gt; t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
        <category>题解</category>
        <category>CodeForces</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 5458 Stability</title>
    <url>/2022/09/06/HDU5458/</url>
    <content><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>给定一个 $n$ 个点 $m$ 条边的无向图。对于图中任何两点 $u$ 和 $v$，如果存在一条边，从图中删去该边能使 $u$ 和 $v$ 的连通性发生改变的边（即原来连通删去该边后变为不连通），那么称该边为相对于 $u$ 和 $v$ 的稳定边。定义 $u$ 和 $v$ 之间的稳定度为当前图中相对于 $u$ 和 $v$ 的稳定边的数量。</p>
<p>给定 $q$ 次操作，每次操作有两种选择：</p>
<ul>
<li><p><code>1 a b</code>：删除 $a$ 和 $b$ 之间直接相连的一条边（保证它存在）；</p>
</li>
<li><p><code>2 a b</code>：询问 $a$ 和 $b$ 之间的稳定度。</p>
</li>
</ul>
<h1 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h1><p>$n\leq3\times10^4$，$m\leq10^5$，$q\leq10^5$。</p>
<p>保证任何时刻图都是联通的。</p>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>显然，一个环上的路径是没有贡献的。</p>
<p>可以想象，如果图原本是一棵树，增加一条 $u$ 到 $v$ 的边的时候成了环，那么等价于 $u$ 到 $v$ （树上）路径上的所有边对答案的贡献变为 $0$（即将边权赋为 $0$）。</p>
<p>题意给的是删边操作，我们可以先处理所有询问结束之后的图，然后倒着处理，那么删边操作就变成了加边操作。</p>
<p>具体做法是，先对最终的图跑一遍生成树，树边的初始边权为 $1$， 遇到环就将路径上的所有边权赋为 $0$，此后的加边操作同理，每次询问的答案即树上距离。</p>
<p>边权可以用树链剖分和线段树维护，时间复杂度为 $O(q\log^2n)$。</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DSU</span> &#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; f, siz;</span><br><span class="line">    <span class="built_in">DSU</span>(<span class="type">int</span> n) : <span class="built_in">f</span>(n + <span class="number">1</span>), <span class="built_in">siz</span>(n + <span class="number">1</span>, <span class="number">1</span>) &#123;</span><br><span class="line">        std::<span class="built_in">iota</span>(f.<span class="built_in">begin</span>(), f.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x != f[x]) x = f[x] = f[f[x]];</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = <span class="built_in">find</span>(x);</span><br><span class="line">        y = <span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (x == y) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (siz[x] &lt; siz[y]) std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">        siz[x] += siz[y];</span><br><span class="line">        f[y] = x;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">same</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(<span class="type">int</span> &amp;x, <span class="type">int</span> y, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    x = y * (r - l + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(<span class="type">int</span> &amp;x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    x &amp;= y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Info</span>, <span class="keyword">class</span> <span class="title class_">Tag</span>,</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Merge</span> = std::plus&lt;Info&gt;&gt;</span><br><span class="line"><span class="keyword">struct</span> LazySegmentTree &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="type">const</span> Merge merge;</span><br><span class="line">    std::vector&lt;Info&gt; info;</span><br><span class="line">    std::vector&lt;Tag&gt; tag;</span><br><span class="line">    <span class="built_in">LazySegmentTree</span>(<span class="type">int</span> n) : <span class="built_in">merge</span>(<span class="built_in">Merge</span>()), <span class="built_in">n</span>(n), <span class="built_in">info</span>(n &lt;&lt; <span class="number">2</span> | <span class="number">1</span>), <span class="built_in">tag</span>(n &lt;&lt; <span class="number">2</span> | <span class="number">1</span>, <span class="number">1</span>) &#123;</span><br><span class="line">        std::function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)&gt; build = [&amp;](<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">                <span class="keyword">if</span> (l != <span class="number">1</span>) info[p] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">            <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">            <span class="built_in">pull</span>(p);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pull</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        info[p] = <span class="built_in">merge</span>(info[p &lt;&lt; <span class="number">1</span>], info[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tag[p] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">apply</span>(p &lt;&lt; <span class="number">1</span>, l, mid, tag[p]);</span><br><span class="line">            <span class="built_in">apply</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, tag[p]);</span><br><span class="line">            tag[p] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">const</span> Tag &amp;x)</span> </span>&#123;</span><br><span class="line">        ::<span class="built_in">apply</span>(info[p], x, l, r);</span><br><span class="line">        ::<span class="built_in">apply</span>(tag[p], x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rangeModify</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> ql, <span class="type">int</span> qr, <span class="type">const</span> Tag &amp;x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr) &#123;</span><br><span class="line">            <span class="built_in">apply</span>(p, l, r, x);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">push</span>(p, l, r);</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (mid &gt;= ql) <span class="built_in">rangeModify</span>(p &lt;&lt; <span class="number">1</span>, l, mid, ql, qr, x); </span><br><span class="line">        <span class="keyword">if</span> (mid &lt; qr) <span class="built_in">rangeModify</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ql, qr, x);</span><br><span class="line">        <span class="built_in">pull</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rangeModify</span><span class="params">(<span class="type">int</span> ql, <span class="type">int</span> qr, <span class="type">const</span> Tag &amp;x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">rangeModify</span>(<span class="number">1</span>, <span class="number">1</span>, n, ql, qr, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Info <span class="title">rangeQuery</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> ql, <span class="type">int</span> qr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ql &gt; r || qr &lt; l) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Info</span>();</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr) &#123;</span><br><span class="line">            <span class="keyword">return</span> info[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">push</span>(p, l, r);</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">merge</span>(<span class="built_in">rangeQuery</span>(p &lt;&lt; <span class="number">1</span>, l, mid, ql, qr), <span class="built_in">rangeQuery</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ql, qr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Info <span class="title">rangeQuery</span><span class="params">(<span class="type">int</span> ql, <span class="type">int</span> qr)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rangeQuery</span>(<span class="number">1</span>, <span class="number">1</span>, n, ql, qr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cas = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, q;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line"></span><br><span class="line">    std::multiset&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; e;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        std::cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        <span class="keyword">if</span> (u &gt; v) std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">        e.<span class="built_in">insert</span>(&#123;u, v&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::array&lt;<span class="type">int</span>, 3&gt;&gt; <span class="built_in">Q</span>(q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; q; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> op, x, y;</span><br><span class="line">        std::cin &gt;&gt; op &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; y) std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">        Q[i] = &#123;op, x, y&#125;;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = e.<span class="built_in">lower_bound</span>(&#123;x, y&#125;);</span><br><span class="line">            <span class="built_in">assert</span>(it != e.<span class="built_in">end</span>());</span><br><span class="line">            e.<span class="built_in">erase</span>(it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adj</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="function">DSU <span class="title">g</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = e.<span class="built_in">begin</span>(); it != e.<span class="built_in">end</span>();) &#123;</span><br><span class="line">        <span class="type">int</span> u = it-&gt;first;</span><br><span class="line">        <span class="type">int</span> v = it-&gt;second;</span><br><span class="line">        <span class="keyword">if</span> (g.<span class="built_in">merge</span>(u, v)) &#123;</span><br><span class="line">            adj[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">            adj[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">            it = e.<span class="built_in">erase</span>(it);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ++it;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">siz</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">dep</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">f</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">son</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    std::function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; dfs1 = [&amp;](<span class="type">int</span> u, <span class="type">int</span> fa) &#123;</span><br><span class="line">        siz[u] = <span class="number">1</span>, dep[u] = dep[fa] + <span class="number">1</span>, f[u] = fa;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : adj[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">dfs1</span>(v, u);</span><br><span class="line">            siz[u] += siz[v];</span><br><span class="line">            <span class="keyword">if</span> (siz[v] &gt; siz[son[u]]) &#123;</span><br><span class="line">                son[u] = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">top</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">dfn</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> now = <span class="number">0</span>;</span><br><span class="line">    std::function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; dfs2 = [&amp;](<span class="type">int</span> u, <span class="type">int</span> leader) &#123;</span><br><span class="line">        top[u] = leader;</span><br><span class="line">        dfn[u] = ++now;</span><br><span class="line">        <span class="keyword">if</span> (son[u]) &#123;</span><br><span class="line">            <span class="built_in">dfs2</span>(son[u], leader);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : adj[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v != f[u] &amp;&amp; v != son[u]) <span class="built_in">dfs2</span>(v, v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">LazySegmentTree&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">seg</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> modify = [&amp;](<span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line">        <span class="keyword">while</span> (top[x] != top[y]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dep[top[x]] &lt; dep[top[y]]) std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">            seg.<span class="built_in">rangeModify</span>(dfn[top[x]], dfn[x], <span class="number">0</span>);</span><br><span class="line">            x = f[top[x]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x != y) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dfn[x] &gt; dfn[y]) std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">            seg.<span class="built_in">rangeModify</span>(dfn[x] + <span class="number">1</span>, dfn[y], <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> get = [&amp;](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (top[x] != top[y]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dep[top[x]] &lt; dep[top[y]]) std::<span class="built_in">swap</span>(x, y); </span><br><span class="line">            res += seg.<span class="built_in">rangeQuery</span>(dfn[top[x]], dfn[x]);</span><br><span class="line">            x = f[top[x]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x != y) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dfn[x] &gt; dfn[y]) std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">            res += seg.<span class="built_in">rangeQuery</span>(dfn[x] + <span class="number">1</span>, dfn[y]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : e) &#123;</span><br><span class="line">        <span class="built_in">modify</span>(it.first, it.second);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = q - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Q[i][<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">modify</span>(Q[i][<span class="number">1</span>], Q[i][<span class="number">2</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="built_in">get</span>(Q[i][<span class="number">1</span>], Q[i][<span class="number">2</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; ++cas &lt;&lt; <span class="string">&quot;:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : ans) &#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    std::cin &gt;&gt; t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
        <category>题解</category>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>树链剖分</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 5293 Tree chain problem</title>
    <url>/2022/09/06/HDU5293/</url>
    <content><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>给定一棵 $n$ 个节点的树和树上的 $m$ 条树上路径，每条给定的路径都有一个价值 $val$。选择一些两两无交点的路径，使它们的价值之和最大。</p>
<h1 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h1><p>$n,m\leq10^5$，$0&lt;val&lt;10^3$。</p>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>考虑树形 $\mathrm{dp}$，设 $\mathrm{dp}[u]$ 为以 $u$ 为根子树中选取两两无交点的路径，价值和的最大值（路径全部在子树中），$\mathrm{sum}[u]$ 为 $u$ 的所有儿子的 $\mathrm{dp}$ 值之和，即 $\mathrm{sum}[u]=\sum_{v\in son(u)}\mathrm{dp}[v]$。</p>
<p>将题目钦定的路径保存在两个端点的 $\mathrm{lca}$ 上，每个节点的处理有两种情况：</p>
<ol>
<li><p>不选该节点储存的路径，$\mathrm{dp}[u]=\mathrm{sum}[u]$；</p>
</li>
<li><p>选择该节点储存的路径，设当前处理的路径两个端点分别为 $u$ 和 $v$，价值为 $w$，有 $\mathrm{dp}[u]=max(\mathrm{dp}[u],w+\sum_{x\in path}\mathrm{sum}[x]-\mathrm{dp}[x])$。后者可以用树链剖分和树状数组维护，注意更新树状数组和 $\mathrm{dp}$ 值的顺序。</p>
</li>
</ol>
<p>时间复杂度为 $O(n\log^2n)$。</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/STACK:1024000000, 1024000000&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fenwick</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> n;</span><br><span class="line">    std::vector&lt;T&gt; a;</span><br><span class="line">    <span class="built_in">Fenwick</span>(<span class="type">int</span> n) : <span class="built_in">n</span>(n), <span class="built_in">a</span>(n + <span class="number">1</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> idx, T val)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = idx; i &lt;= n; i += i &amp; -i) &#123;</span><br><span class="line">            a[i] += val; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">sum</span><span class="params">(<span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">        T res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = idx; i &gt; <span class="number">0</span>; i -= i &amp; -i) &#123;</span><br><span class="line">            res += a[i];      </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">rangeSum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(r) - <span class="built_in">sum</span>(l - <span class="number">1</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adj</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        std::cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        adj[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        adj[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">siz</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">dep</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">f</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">son</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    std::function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; dfs1 = [&amp;](<span class="type">int</span> u, <span class="type">int</span> fa) &#123;</span><br><span class="line">        siz[u] = <span class="number">1</span>, dep[u] = dep[fa] + <span class="number">1</span>, f[u] = fa;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : adj[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">dfs1</span>(v, u);</span><br><span class="line">            siz[u] += siz[v];</span><br><span class="line">            <span class="keyword">if</span> (siz[v] &gt; siz[son[u]]) &#123;</span><br><span class="line">                son[u] = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">top</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">dfn</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> now = <span class="number">0</span>;</span><br><span class="line">    std::function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; dfs2 = [&amp;](<span class="type">int</span> u, <span class="type">int</span> leader) &#123;</span><br><span class="line">        top[u] = leader;</span><br><span class="line">        dfn[u] = ++now;</span><br><span class="line">        <span class="keyword">if</span> (son[u]) &#123;</span><br><span class="line">            <span class="built_in">dfs2</span>(son[u], leader);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : adj[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v != f[u] &amp;&amp; v != son[u]) <span class="built_in">dfs2</span>(v, v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> lca = [&amp;](<span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line">        <span class="keyword">while</span> (top[x] != top[y]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dep[top[x]] &lt; dep[top[y]]) &#123;</span><br><span class="line">                std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">            &#125;</span><br><span class="line">            x = f[top[x]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dep[x] &lt; dep[y] ? x : y;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::vector&lt;std::array&lt;<span class="type">int</span>, 3&gt;&gt;&gt; <span class="built_in">g</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> u, v, w;</span><br><span class="line">        std::cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        g[<span class="built_in">lca</span>(u, v)].<span class="built_in">push_back</span>(&#123;u, v, w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Fenwick&lt;i64&gt; <span class="title">sdp</span><span class="params">(n)</span>, <span class="title">ss</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> get = [&amp;](<span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line">        i64 rdp = <span class="number">0</span>, rs = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (top[x] != top[y]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dep[top[x]] &lt; dep[top[y]]) &#123;</span><br><span class="line">                std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">            &#125;</span><br><span class="line">            rdp += sdp.<span class="built_in">rangeSum</span>(dfn[top[x]], dfn[x]);</span><br><span class="line">            rs += ss.<span class="built_in">rangeSum</span>(dfn[top[x]], dfn[x]);</span><br><span class="line">            x = f[top[x]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dfn[x] &gt; dfn[y]) std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">        rdp += sdp.<span class="built_in">rangeSum</span>(dfn[x], dfn[y]);</span><br><span class="line">        rs += ss.<span class="built_in">rangeSum</span>(dfn[x], dfn[y]);</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_pair</span>(rdp, rs);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;i64&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">sum</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    std::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> u) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : adj[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v == f[u]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(v);</span><br><span class="line">            sum[u] += dp[v];</span><br><span class="line">        &#125;</span><br><span class="line">        dp[u] = sum[u];</span><br><span class="line">        ss.<span class="built_in">modify</span>(dfn[u], sum[u]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : g[u]) &#123;</span><br><span class="line">            <span class="keyword">auto</span> res = <span class="built_in">get</span>(x[<span class="number">0</span>], x[<span class="number">1</span>]);</span><br><span class="line">            dp[u] = std::<span class="built_in">max</span>(dp[u], x[<span class="number">2</span>] + res.second - res.first);</span><br><span class="line">        &#125;</span><br><span class="line">        sdp.<span class="built_in">modify</span>(dfn[u], dp[u]);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; dp[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    std::cin &gt;&gt; t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
        <category>题解</category>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>树链剖分</tag>
        <tag>树形dp</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>ICPC「2021上海」H. Life is a Game</title>
    <url>/2022/09/19/ICPC2021%E4%B8%8A%E6%B5%B7H/</url>
    <content><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>给定一张 $n$ 个点 $m$ 条边的无向图，每个点有一个点权 $a_i$。从一个点出发，初始有 $k$ 的能量，首次到达一个点可以获得等于该点点权的能量。同时每条边有一个边权，只有当前能量不小于边权时才能通过该边（通过边不会消耗能量）。有 $q$ 组<strong>独立</strong>的询问，每次给定出发点 $x$ 和初始能量 $k$，求最大能积累的能量值。</p>
<h1 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h1><p>$n,m,q\leq10^5$，$a_i\leq10^4$，$w,k\leq10^9$。</p>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>显然，不在最小生成树上的边走了肯定不会更优。</p>
<p>将询问离线，储存在出发点 $x$ 上，每个点开一个堆储存询问。</p>
<p>跑最小生成树（$\mathrm{kruskal}$），如果当前的边能加进去（为最小生成树边），就将两个端点的堆合并。</p>
<p>合并步骤：</p>
<ul>
<li>跑最小生成树的同时维护出每个连通块的和。</li>
<li>先将两个堆中<strong>初始能力值 + 目前能获得的能力值</strong>小于边权 $w$ 的点弹出堆。</li>
<li>然后合并两个堆的询问。</li>
<li>最后在并查集中合并两个点。</li>
</ul>
<p>对于两个堆询问的合并，有两种方法：</p>
<ul>
<li>采用可并堆（可以 $O(\log n)$ 合并）。</li>
<li>普通二叉堆+启发式合并。</li>
</ul>
<h1 id="Code（二叉堆-启发式合并）"><a href="#Code（二叉堆-启发式合并）" class="headerlink" title="Code（二叉堆+启发式合并）"></a>Code（二叉堆+启发式合并）</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> u, v, w;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w) : <span class="built_in">u</span>(u), <span class="built_in">v</span>(v), <span class="built_in">w</span>(w) &#123;&#125;</span><br><span class="line">    <span class="built_in">Edge</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Edge &amp;a, <span class="type">const</span> Edge &amp;b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; e[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Q</span> &#123;</span><br><span class="line">    <span class="type">int</span> k, id;</span><br><span class="line">    <span class="built_in">Q</span>(<span class="type">int</span> k, <span class="type">int</span> id) : <span class="built_in">k</span>(k), <span class="built_in">id</span>(id) &#123;&#125;</span><br><span class="line">    <span class="built_in">Q</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Q &amp;a, <span class="type">const</span> Q &amp;b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.k &gt; b.k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, q;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line">ll a[N], ans[N];</span><br><span class="line">priority_queue&lt;Q&gt; h[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == f[x]) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> f[x] = <span class="built_in">find</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; e[i].u &gt;&gt; e[i].v &gt;&gt; e[i].w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(e + <span class="number">1</span>, e + m + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; q; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> x, k;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; k;</span><br><span class="line">        h[x].<span class="built_in">emplace</span>(k, i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">iota</span>(f + <span class="number">1</span>, f + n + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [u, v, w] = e[i];</span><br><span class="line"></span><br><span class="line">        u = <span class="built_in">find</span>(u), v = <span class="built_in">find</span>(v);</span><br><span class="line">        <span class="keyword">if</span> (u == v) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!h[u].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [k, id] = h[u].<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (k + a[u] &lt; w) &#123;</span><br><span class="line">                h[u].<span class="built_in">pop</span>();</span><br><span class="line">                ans[id] = a[u] + k;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!h[v].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [k, id] = h[v].<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (k + a[v] &lt; w) &#123;</span><br><span class="line">                h[v].<span class="built_in">pop</span>();</span><br><span class="line">                ans[id] = a[v] + k;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (h[u].<span class="built_in">size</span>() &lt; h[v].<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(u, v);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!h[v].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> x = h[v].<span class="built_in">top</span>();</span><br><span class="line">            h[v].<span class="built_in">pop</span>();</span><br><span class="line">            h[u].<span class="built_in">push</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        f[v] = u;</span><br><span class="line">        a[u] += a[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x = <span class="built_in">find</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (!h[x].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [k, id] = h[x].<span class="built_in">top</span>();</span><br><span class="line">        h[x].<span class="built_in">pop</span>();</span><br><span class="line">        ans[id] = k + a[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; q; ++i) &#123;</span><br><span class="line">        cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
        <category>题解</category>
        <category>ICPC</category>
      </categories>
      <tags>
        <tag>启发式合并</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>ICPC「2022网络赛1」L. LCS-like Problem</title>
    <url>/2022/09/19/ICPC2022%E7%BD%91%E7%BB%9C%E8%B5%9B1L/</url>
    <content><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>给定两个字符串 $s$，$t$。求 $s$ 中最长的与 $t$ 最长公共子序列长度小于等于 $1$ 的子序列的长度。</p>
<h1 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h1><p>$|s|,|t|\leq5\times10^5$。</p>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>首先，如果 $s$ 串中某个字母在 $t$ 串中没有出现过，那么一定可以加入答案中；$s$ 串中没有出现过的字母对答案没有贡献。</p>
<p>再考虑在 $s$ 和 $t$ 串中都出现过的字母。设当前枚举到位置 $i$，考虑能从之前哪几个位置转移。能从位置 $j$ 转移的条件是 $t$ 串中 $\mathrm s[j]$ 最先出现的位置大于等于 $\mathrm s[i]$ 最后出现的位置。这样可以得出一个 $O({|s|}^2)$ 的转移方程。</p>
<p>我们只要统计出当前每个字母对应的最大 $\mathrm{dp}$ 值，每次转移可以只枚举 $26$ 个字母，这样就可以把复杂度压至 $O(26|s|)$ 了。</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    std::string s, t;</span><br><span class="line">    std::cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">length</span>(), m = t.<span class="built_in">length</span>();</span><br><span class="line">    s = <span class="string">&quot; &quot;</span> + s, t = <span class="string">&quot; &quot;</span> + t;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">first</span><span class="params">(<span class="number">26</span>)</span>, <span class="title">last</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> u = t[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (first[u] == <span class="number">0</span>) &#123;</span><br><span class="line">            first[u] = last[u] = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            last[u] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> ultra = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> ndp = <span class="number">1</span>, u = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (first[u] == <span class="number">0</span>) &#123;</span><br><span class="line">            ultra++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first[j] &gt;= last[u]) &#123;</span><br><span class="line">                ndp = std::<span class="built_in">max</span>(ndp, dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[u] = std::<span class="built_in">max</span>(dp[u], ndp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; *std::<span class="built_in">max_element</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>()) + ultra &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
        <category>题解</category>
        <category>ICPC</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>P4396「AHOI2013」作业</title>
    <url>/2022/09/05/P4396/</url>
    <content><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>给定一个长度为 $n$ 的序列 $a_n$，$m$ 次询问，每次询问给定 <code>l r a b</code>，求区间 $[l,r]$ 内大于等于 $a$ 且小于等于 $b$ 的数的个数，以及满足条件的不同数字的种数。</p>
<h1 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h1><p>$n,m\leq10^5$，$1\leq a_i\leq10^5$。</p>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>容易想到莫队，但是对于区间的统计，如果直接莫队的话，需要使用树状数组/线段树等数据结构维护区间，时间复杂度会变成 $O(n\sqrt m\log N)$，显然无法接受。</p>
<p>朴素的想法，莫队的每次更新是 $O(1)$ 的，查询是 $O(N)$ 的。因为有 $n\sqrt m$ 次更新操作和 $m$ 次查询操作，显然更新比查询对复杂度的要求更苛刻。如果我们可以 $O(1)$ 地更新、$O(\sqrt N)$ 地查询，那么复杂度是可以接受的。</p>
<p>值域分块可以做到这一点。由于是单点更新，显然可以在 $O(1)$ 的时间内完成对单点和块的更新，分块的查询是 $O(\sqrt N)$ 的，所以总复杂度为 $O(n\sqrt m+m\sqrt N)$。</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        std::cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::array&lt;<span class="type">int</span>, 5&gt;&gt; <span class="built_in">Q</span>(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        std::cin &gt;&gt; Q[i][<span class="number">0</span>] &gt;&gt; Q[i][<span class="number">1</span>] &gt;&gt; Q[i][<span class="number">2</span>] &gt;&gt; Q[i][<span class="number">3</span>];</span><br><span class="line">        Q[i][<span class="number">4</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = std::<span class="built_in">sqrt</span>(n);</span><br><span class="line">    std::<span class="built_in">sort</span>(Q.<span class="built_in">begin</span>(), Q.<span class="built_in">end</span>(), [&amp;](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((x[<span class="number">0</span>] - <span class="number">1</span>) / len != (y[<span class="number">0</span>] - <span class="number">1</span>) / len) <span class="keyword">return</span> x[<span class="number">0</span>] &lt; y[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> ((x[<span class="number">0</span>] - <span class="number">1</span>) / len &amp; <span class="number">1</span>) <span class="keyword">return</span> x[<span class="number">1</span>] &gt; y[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> x[<span class="number">1</span>] &lt; y[<span class="number">1</span>];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> siz = std::<span class="built_in">sqrt</span>(N);</span><br><span class="line">    <span class="type">int</span> num = (N + siz - <span class="number">1</span>) / siz;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">st</span><span class="params">(num + <span class="number">1</span>)</span>, <span class="title">ed</span><span class="params">(num + <span class="number">1</span>)</span>, <span class="title">id</span><span class="params">(N + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= num; ++i) &#123;</span><br><span class="line">        st[i] = ed[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        ed[i] = std::<span class="built_in">min</span>(st[i] + siz - <span class="number">1</span>, N);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = st[i]; j &lt;= ed[i]; ++j) &#123;</span><br><span class="line">            id[j] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">ans</span>(m);</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(N + <span class="number">1</span>)</span>, <span class="title">sum</span><span class="params">(num + <span class="number">1</span>)</span>, <span class="title">ap</span><span class="params">(num + <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> add = [&amp;](<span class="type">int</span> x) &#123;</span><br><span class="line">        cnt[a[x]]++;</span><br><span class="line">        sum[id[a[x]]]++;</span><br><span class="line">        <span class="keyword">if</span> (cnt[a[x]] == <span class="number">1</span>) ap[id[a[x]]]++;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> del = [&amp;](<span class="type">int</span> x) &#123;</span><br><span class="line">        cnt[a[x]]--;</span><br><span class="line">        sum[id[a[x]]]--;</span><br><span class="line">        <span class="keyword">if</span> (cnt[a[x]] == <span class="number">0</span>) ap[id[a[x]]]--;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> query = [&amp;](<span class="type">int</span> fr, <span class="type">int</span> to) -&gt; std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &#123;</span><br><span class="line">        <span class="type">int</span> res1 = <span class="number">0</span>, res2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = fr; i &lt;= std::<span class="built_in">min</span>(ed[id[fr]], to); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[i]) res1 += cnt[i], res2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (id[fr] != id[to]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = std::<span class="built_in">max</span>(fr, st[id[to]]); i &lt;= to; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cnt[i]) res1 += cnt[i], res2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = id[fr] + <span class="number">1</span>; i &lt; id[to]; ++i) &#123;</span><br><span class="line">            res1 += sum[i];</span><br><span class="line">            res2 += ap[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;res1, res2&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [ql, qr, fr, to, id] : Q) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &gt; ql) <span class="built_in">add</span>(--l);</span><br><span class="line">        <span class="keyword">while</span> (r &lt; qr) <span class="built_in">add</span>(++r);</span><br><span class="line">        <span class="keyword">while</span> (l &lt; ql) <span class="built_in">del</span>(l++);</span><br><span class="line">        <span class="keyword">while</span> (r &gt; qr) <span class="built_in">del</span>(r--);</span><br><span class="line">        ans[id] = <span class="built_in">query</span>(fr, to);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [x, y] : ans) &#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
        <category>题解</category>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>莫队</tag>
        <tag>值域分块</tag>
      </tags>
  </entry>
  <entry>
    <title>长链剖分</title>
    <url>/2022/09/11/%E9%95%BF%E9%93%BE%E5%89%96%E5%88%86/</url>
    <content><![CDATA[<h1 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>在重链剖分中，我们将子树大小最大的儿子定义为重儿子。由于其具有优秀的性质（任何点到根节点的路径最多经过 $\log n$ 条树链），我们经常用它来维护树信息。同样的，我们也可以将<strong>子树最大深度</strong>最大的儿子定义为<strong>长儿子</strong>，对树进行<strong>长链剖分</strong>。</p>
<p>和重链剖分类似。第一遍 $\mathrm{dfs}$ 预处理出每个点的父节点、深度、子树最大深度和长儿子，第二遍 $\mathrm{dfs}$ 求得每个节点所在链的链顶节点，即 $\mathrm{top}[x]$。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">dep</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">mxdep</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">son</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">std::function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; dfs1 = [&amp;](<span class="type">int</span> u, <span class="type">int</span> fa) &#123;</span><br><span class="line">    mxdep[u] = dep[u] = dep[fa] + <span class="number">1</span>;</span><br><span class="line">    f[u] = fa;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : adj[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(v, u);</span><br><span class="line">        <span class="keyword">if</span> (mxdep[v] &gt; mxdep[u]) &#123;</span><br><span class="line">            mxdep[u] = mxdep[v];</span><br><span class="line">            son[u] = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">top</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">std::function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; dfs2 = [&amp;](<span class="type">int</span> u, <span class="type">int</span> leader) &#123;</span><br><span class="line">    top[u] = leader;</span><br><span class="line">    <span class="keyword">if</span> (son[u]) &#123;</span><br><span class="line">        <span class="built_in">dfs2</span>(son[u], leader);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : adj[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v != f[u] &amp;&amp; v != son[u]) &#123;</span><br><span class="line">            <span class="built_in">dfs2</span>(v, v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h1 id="最近公共祖先"><a href="#最近公共祖先" class="headerlink" title="最近公共祖先"></a>最近公共祖先</h1><p><strong>长链剖分可以在 $O(\sqrt n)$ 的时间内求出树上两点的最近公共祖先。</strong></p>
<p>证明：该命题等价为<strong>树上任何一个点到根节点的路径最多经过 $\sqrt n$ 条链</strong>。设一次跳跃操作为 $x\rightarrow \mathrm f[\mathrm{top}[x]]$（和重链剖分类似），并且点 $x$ 到根节点要经过 $c$ 次跳跃操作。由于一次跳跃操作后，点 $x$ 所在的链的链长至少加 $1$，所以最坏情况是 $c*(c+1)=n$（$n$ 为节点数），可以看到 $c$ 是根号级别的。</p>
<p>当然，一般不会用长链剖分来求 $\mathrm{lca}$，因为有重链剖分/倍增等更加优秀的在线算法。</p>
<h1 id="树上-k-级祖先"><a href="#树上-k-级祖先" class="headerlink" title="树上 k 级祖先"></a>树上 k 级祖先</h1><p><strong>长链剖分可以 $O(n\log n)$ 预处理和 $O(1)$ 查询树上任何点 $k$ 级祖先。</strong></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我们可以在长链剖分的同时，在 $O(n\log n)$ 的时间内预处理出每个点的 $2^k$（$k=0,1,2\dots$）级祖先，方法和倍增 $\mathrm{lca}$ 类似。并且对于每个链顶节点，设其链长为 $len$，预处理出其向上的 $len$ 个节点和（延该链）向下的 $len$ 个节点，很明显，其时间和空间复杂度都是 $O(n)$ 的。每次询问，我们直接 $O(1)$ 地跳到最高的 $2$ 的次幂级祖先（$\mathrm f[x][2^{\lfloor log_2k\rfloor}]$）所在链的链顶，然后在通过之前预处理出的向上和向下的节点编号，就可以 $O(1)$ 地完成查询。</p>
<p>下面证明为什么 $k$ 级祖先一定在向上或者向下的 $len$ 个节点内。</p>
<p>长链剖分有一个性质，<strong>一个点的 $k$ 级祖先所在的链长度一定大于等于该点到 $k$ 级祖先的距离</strong>。这个性质很容易证明，因为如果小于，则可以选取该点到 $k$ 级祖先这条链为长链。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/z9bw49ww.png" alt=""></p>
<p>参考上图，设第一步已经跳到了点 $q$，若 $k$ 级祖先位于 $q$ 和 $\mathrm{top}[q]$ 之间，显然一定在 $len$ 的范围内。若是在 $\mathrm{top}[q]$ 上方，由于 $x&gt;y$，所以 $len\geq x&gt;y$，因此也一定在 $len$ 的范围内（即使 $k$ 级祖先所在的链不经过 $x$ 也满足）。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><a href="https://www.luogu.com.cn/problem/P5903">P5903「模板」树上 k 级祖先</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> u32 = <span class="type">unsigned</span> <span class="type">int</span>;</span><br><span class="line"></span><br><span class="line">u32 s;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> u32 <span class="title">get</span><span class="params">(u32 x)</span> </span>&#123;</span><br><span class="line">    x ^= x &lt;&lt; <span class="number">13</span>;</span><br><span class="line">    x ^= x &gt;&gt; <span class="number">17</span>;</span><br><span class="line">    x ^= x &lt;&lt; <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">return</span> s = x; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, q;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; q &gt;&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> rt;</span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adj</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        std::cin &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) rt = i;</span><br><span class="line">        <span class="keyword">else</span> adj[x].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">lg</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        lg[i] = lg[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n + <span class="number">1</span>, std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(lg[n] + <span class="number">1</span>));</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">dep</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">mxdep</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">son</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    std::function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; dfs1 = [&amp;](<span class="type">int</span> u, <span class="type">int</span> fa) &#123;</span><br><span class="line">        mxdep[u] = dep[u] = dep[fa] + <span class="number">1</span>;</span><br><span class="line">        f[u][<span class="number">0</span>] = fa;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= lg[dep[u]]; ++i) &#123;</span><br><span class="line">            f[u][i] = f[f[u][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : adj[u]) &#123;</span><br><span class="line">            <span class="built_in">dfs1</span>(v, u);</span><br><span class="line">            <span class="keyword">if</span> (mxdep[v] &gt; mxdep[u]) &#123;</span><br><span class="line">                mxdep[u] = mxdep[v];</span><br><span class="line">                son[u] = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">top</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">up</span>(n + <span class="number">1</span>), <span class="built_in">down</span>(n + <span class="number">1</span>);</span><br><span class="line">    std::function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; dfs2 = [&amp;](<span class="type">int</span> u, <span class="type">int</span> leader) &#123;</span><br><span class="line">        top[u] = leader;</span><br><span class="line">        <span class="keyword">if</span> (u == leader) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = u, k = u; i &lt;= mxdep[u] - dep[u]; ++i) &#123;</span><br><span class="line">                up[u].<span class="built_in">push_back</span>(j);</span><br><span class="line">                down[u].<span class="built_in">push_back</span>(k);</span><br><span class="line">                j = f[j][<span class="number">0</span>], k = son[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (son[u]) &#123;</span><br><span class="line">            <span class="built_in">dfs2</span>(son[u], leader);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : adj[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v != son[u]) &#123;</span><br><span class="line">                <span class="built_in">dfs2</span>(v, v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs1</span>(rt, rt);</span><br><span class="line">    <span class="built_in">dfs2</span>(rt, rt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> query = [&amp;](<span class="type">int</span> x, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">        x = f[x][lg[k]];</span><br><span class="line">        k -= (<span class="number">1</span> &lt;&lt; lg[k]) + dep[x] - dep[top[x]];</span><br><span class="line">        x = top[x];</span><br><span class="line">        <span class="keyword">return</span> k &gt;= <span class="number">0</span> ? up[x][k] : down[x][-k];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> lastans = <span class="number">0</span>;</span><br><span class="line">    i64 ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> x = (<span class="built_in">get</span>(s) ^ lastans) % n + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> k = (<span class="built_in">get</span>(s) ^ lastans) % dep[x];</span><br><span class="line">        lastans = <span class="built_in">query</span>(x, k);</span><br><span class="line">        ans ^= <span class="number">1LL</span> * i * lastans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="优化树形-dp"><a href="#优化树形-dp" class="headerlink" title="优化树形 dp"></a>优化树形 dp</h2><p>待补。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>算法</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>长链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title>P4145 上帝造题的七分钟 2</title>
    <url>/2022/09/06/P4145/</url>
    <content><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>给定一个长度为 $n$ 的序列 $a_n$，$m$ 次操作，每次给定 <code>k l r</code>：</p>
<ul>
<li>$k=0$ 表示给 $[l,r]$ 中的每个数开平方（下取整）。</li>
<li>$k=1$ 表示询问 $[l,r]$ 中各个数的和。</li>
</ul>
<h1 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h1><p>$n,m\leq10^5$，$0&lt;a_i\leq10^{12}$。</p>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>一个数不断开平方根（下取整）直到 $1$，其次数是不到 $\log n$ 的。通过运算可以得到，$10^{12}$ 开 $6$ 次平方根可以得到 $1$，因此可以把它当成常数级的。</p>
<p>如果对修改区间内不为 $1$ 的点暴力进行单点修改，总修改次数最多为 $6n$。考虑用树状数组/线段树维护区间和，总的修改复杂度最坏为 $O(6n\log n)$（查询的复杂度显然是 $O(m\log n)$）。</p>
<p>我们可以用并查集来跳过 $1$。设 $a_j$ 是一个不为 $1$ 的数，$a_i$ 是其前面最近的不为 $1$ 的数。我们可以把 $[i+1,j]$ 归为一段，并查集中每棵树代表一个段，其根节点为右端点，每次更新根节点（右端点）即可。如果更新后值变为 $1$，则将该段和下一段合并。</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fenwick</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> n;</span><br><span class="line">    std::vector&lt;T&gt; a;</span><br><span class="line">    <span class="built_in">Fenwick</span>(<span class="type">int</span> n) : <span class="built_in">n</span>(n), <span class="built_in">a</span>(n + <span class="number">1</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> idx, T val)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = idx; i &lt;= n; i += i &amp; -i) &#123;</span><br><span class="line">            a[i] += val; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">sum</span><span class="params">(<span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">        T res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = idx; i &gt; <span class="number">0</span>; i -= i &amp; -i) &#123;</span><br><span class="line">            res += a[i];      </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">rangeSum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(r) - <span class="built_in">sum</span>(l - <span class="number">1</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;i64&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        std::cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(n + <span class="number">2</span>)</span></span>;</span><br><span class="line">    std::<span class="built_in">iota</span>(next.<span class="built_in">begin</span>(), next.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> find = [&amp;](<span class="type">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x != next[x]) x = next[x] = next[next[x]];</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">Fenwick&lt;i64&gt; <span class="title">fen</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        fen.<span class="built_in">modify</span>(i, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    std::cin &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="type">int</span> op, l, r;</span><br><span class="line">        std::cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) std::<span class="built_in">swap</span>(l, r);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">                i = <span class="built_in">find</span>(i);</span><br><span class="line">                <span class="keyword">if</span> (i &gt; r) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                i64 nv = std::<span class="built_in">sqrt</span>(a[i]);</span><br><span class="line">                fen.<span class="built_in">modify</span>(i, nv - a[i]);</span><br><span class="line">                a[i] = nv;</span><br><span class="line">                <span class="keyword">if</span> (a[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                    next[i] = <span class="built_in">find</span>(i + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; fen.<span class="built_in">rangeSum</span>(l, r) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
        <category>题解</category>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>暴力</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>P5047 Yuno loves sqrt technology II</title>
    <url>/2022/09/05/P5047/</url>
    <content><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>给定一个长度为 $n$ 的序列 $a_n$，$m$ 次询问，每次询问给定 <code>l r</code>，查询区间 $[l,r]$ 内的逆序对数。</p>
<h1 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h1><p>$n,m\leq10^5$，$0\leq a_i\leq10^9$。</p>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>先考虑暴力莫队的做法，每次更新时维护一个树状数组，这样做的复杂度为 $O(n\sqrt m\log n)$。我们以往遇到这样更新和查询不平衡的问题的时候，往往想到值域分块。但是此题显然没法像以前那样 $O(1)$ 更新，$O(\sqrt n)$ 查询，所以，我们希望能够优化更新的次数（$n\sqrt m$ 的更新次数显然不够优秀）。</p>
<p>我们来分析莫队指针的移动。以右指针向右移动为例，当指针 $r$ 移动到 $r’$ 的位置时（此时左指针位于 $l$ 处），对贡献的增加值为 $\sum_{i=r}^{i=r’}f(l,i-1,i)$（其中 $f(l,r,x)$ 为 区间 $[l,r]$ 中比 $a[x]$ 大的数的个数）。这个值是可以差分的，即 $f(l,i-1,i)=f(1,i-1,i)-f(1,l-1,i)$。前面一项（被减数）非常容易预处理，用树状数组扫一遍即可，我们来考虑对后面一项的处理。</p>
<p>由于莫队指针的移动最多有 $n\sqrt m$ 次，因此 $f(1,l-1,i)$ 最多会被计算 $n\sqrt m$ 次，我们需要找到一个在 $O(1)$ 时间内计算其值的方法。</p>
<p>我们可以将莫队指针的移动离线（俗称二次离线，第一次指把询问离线，第二次指把莫队指针的移动离线）。我们还是以右指针向右移动为例，把每次右指针的移动记录在左指针上（对每个点开一个 <code>std::vector</code> 来保存右指针信息），由于询问次数为 $m$，所以最多有 $m$ 个不同的右指针下标，空间复杂度为 $O(m)$。</p>
<p>考虑从左往右扫一遍，一次同时处理一个点保存的右指针信息。我们要求的是 $1$ 到 $l-1$ 中比 $a[r]$（假设当前正在处理的右指针下标为 $r$）大的数的个数。我们考虑维护一个数据结构，从左往右扫的过程中按顺序把该点的值插入这个数据结构中，我们要查询的答案为当前数据结构中比 $a[r]$ 大的数的个数。这很容易实现，树状数组/线段树/分块…都能解决这个问题。但是我们只关心复杂度，由于有 $n\sqrt m$ 次查询，所以我们必须要求在 $O(1)$ 的时间内完成查询。至于更新操作，由于每个点只更新一次，所以有且仅有 $n$ 次更新，我们可以放宽更新的复杂度要求。</p>
<p>还是考虑值域分块。很显然，我们查询的是一个前/后缀和的形式，我们考虑维护一个后缀和块状数组，每次更新所有小于该点的值（用打 $\mathrm{tag}$ 的方式在 $O(\sqrt n)$ 的时间内完成），表明所有小于该点的值在被查询的时候贡献会加 $1$，此时每个点的值代表当前比该点大的数的个数，查询显然就是 $O(1)$ 的了（直接返回该点的值即可）.</p>
<p>以上分析全部以右指针向右移动为例，其他的指针移动情况都可以类似考虑。</p>
<p>那么问题似乎全部得到了解决，但其实还没有完，我们维护的其实是相较于上一次处理的询问的变化值，我们只需做一个按处理顺序的前缀累加就能得到答案。</p>
<p>如果感觉这题卡常，检查一下是否存开了很多不必要的 $\mathrm{long}\ \mathrm{long}$。</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Info</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fenwick</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> n;</span><br><span class="line">    std::vector&lt;Info&gt; info;</span><br><span class="line">    <span class="built_in">Fenwick</span>(<span class="type">int</span> n) : <span class="built_in">n</span>(n), <span class="built_in">info</span>(n + <span class="number">1</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> idx, Info val)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = idx; i &lt;= n; i += i &amp; -i) info[i] += val; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Info <span class="title">query</span><span class="params">(<span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">        Info res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = idx; i &gt; <span class="number">0</span>; i -= i &amp; -i) res += info[i];      </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Info <span class="title">rangeQuery</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">query</span>(r) - <span class="built_in">query</span>(l - <span class="number">1</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        std::cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> b = a;</span><br><span class="line">    std::<span class="built_in">sort</span>(b.<span class="built_in">begin</span>() + <span class="number">1</span>, b.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> tot = std::<span class="built_in">unique</span>(b.<span class="built_in">begin</span>() + <span class="number">1</span>, b.<span class="built_in">end</span>()) - b.<span class="built_in">begin</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        a[i] = std::<span class="built_in">lower_bound</span>(b.<span class="built_in">begin</span>() + <span class="number">1</span>, b.<span class="built_in">begin</span>() + tot + <span class="number">1</span>, a[i]) - b.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::array&lt;<span class="type">int</span>, 3&gt;&gt; <span class="built_in">Q</span>(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        std::cin &gt;&gt; Q[i][<span class="number">0</span>] &gt;&gt; Q[i][<span class="number">1</span>];</span><br><span class="line">        Q[i][<span class="number">2</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = std::<span class="built_in">sqrt</span>(n);</span><br><span class="line">    std::<span class="built_in">sort</span>(Q.<span class="built_in">begin</span>(), Q.<span class="built_in">end</span>(), [&amp;](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((x[<span class="number">0</span>] - <span class="number">1</span>) / len != (y[<span class="number">0</span>] - <span class="number">1</span>) / len) <span class="keyword">return</span> x[<span class="number">0</span>] &lt; y[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> ((x[<span class="number">0</span>] - <span class="number">1</span>) / len &amp; <span class="number">1</span>) <span class="keyword">return</span> x[<span class="number">1</span>] &gt; y[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> x[<span class="number">1</span>] &lt; y[<span class="number">1</span>];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="function">Fenwick&lt;<span class="type">int</span>&gt; <span class="title">fen</span><span class="params">(tot + <span class="number">1</span>)</span></span>;</span><br><span class="line">    std::vector&lt;std::array&lt;i64, 2&gt;&gt; <span class="built_in">sum</span>(n + <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        sum[i][<span class="number">0</span>] = sum[i - <span class="number">1</span>][<span class="number">0</span>] + fen.<span class="built_in">rangeQuery</span>(a[i] + <span class="number">1</span>, tot + <span class="number">1</span>);</span><br><span class="line">        fen.<span class="built_in">modify</span>(a[i], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">fill</span>(fen.info.<span class="built_in">begin</span>(), fen.info.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        sum[i][<span class="number">1</span>] = sum[i + <span class="number">1</span>][<span class="number">1</span>] + fen.<span class="built_in">query</span>(a[i] - <span class="number">1</span>);</span><br><span class="line">        fen.<span class="built_in">modify</span>(a[i], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::vector&lt;std::array&lt;<span class="type">int</span>, 4&gt;&gt;&gt; <span class="built_in">L</span>(n + <span class="number">1</span>), <span class="built_in">R</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="function">std::vector&lt;i64&gt; <span class="title">ans</span><span class="params">(m)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [x, y, z] : Q) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; y) &#123;</span><br><span class="line">            ans[z] += sum[y][<span class="number">0</span>] - sum[r][<span class="number">0</span>];</span><br><span class="line">            L[l].<span class="built_in">push_back</span>(&#123;r + <span class="number">1</span>, y, <span class="number">-1</span>, z&#125;);</span><br><span class="line">            r = y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r &gt; y) &#123;</span><br><span class="line">            ans[z] -= sum[r][<span class="number">0</span>] - sum[y][<span class="number">0</span>];</span><br><span class="line">            L[l].<span class="built_in">push_back</span>(&#123;y + <span class="number">1</span>, r, <span class="number">1</span>, z&#125;);</span><br><span class="line">            r = y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; x) &#123;</span><br><span class="line">            ans[z] -= sum[l][<span class="number">1</span>] - sum[x][<span class="number">1</span>];</span><br><span class="line">            R[r].<span class="built_in">push_back</span>(&#123;l, x - <span class="number">1</span>, <span class="number">1</span>, z&#125;);</span><br><span class="line">            l = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; x) &#123;</span><br><span class="line">            ans[z] += sum[x][<span class="number">1</span>] - sum[l][<span class="number">1</span>];</span><br><span class="line">            R[r].<span class="built_in">push_back</span>(&#123;x, l - <span class="number">1</span>, <span class="number">-1</span>, z&#125;);</span><br><span class="line">            l = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> siz = std::<span class="built_in">sqrt</span>(tot);</span><br><span class="line">    <span class="type">int</span> num = (tot + siz - <span class="number">1</span>) / siz;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">st</span><span class="params">(num + <span class="number">1</span>)</span>, <span class="title">ed</span><span class="params">(num + <span class="number">1</span>)</span>, <span class="title">id</span><span class="params">(tot + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= num; ++i) &#123;</span><br><span class="line">        st[i] = ed[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        ed[i] = std::<span class="built_in">min</span>(st[i] + siz - <span class="number">1</span>, tot);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = st[i]; j &lt;= ed[i]; ++j) &#123;</span><br><span class="line">            id[j] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;i64&gt; <span class="title">cnt</span><span class="params">(tot + <span class="number">1</span>)</span>, <span class="title">tag</span><span class="params">(num + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> addl = [&amp;](<span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tag[id[val]]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = st[id[val]]; i &lt;= ed[id[val]]; ++i) &#123;</span><br><span class="line">                cnt[i] += tag[id[val]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tag[id[val]] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = st[id[val]]; i &lt; val; ++i) &#123;</span><br><span class="line">            ++cnt[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; id[val]; ++i) &#123;</span><br><span class="line">            ++tag[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> addr = [&amp;](<span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tag[id[val]]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = st[id[val]]; i &lt;= ed[id[val]]; ++i) &#123;</span><br><span class="line">                cnt[i] += tag[id[val]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tag[id[val]] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = val + <span class="number">1</span>; i &lt;= ed[id[val]]; ++i) &#123;</span><br><span class="line">            ++cnt[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = id[val] + <span class="number">1</span>; i &lt;= num; ++i) &#123;</span><br><span class="line">            ++tag[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [fr, to, val, z] : L[i]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = fr; j &lt;= to; ++j) &#123;</span><br><span class="line">                ans[z] += val * (cnt[a[j]] + tag[id[a[j]]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">addl</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">fill</span>(cnt.<span class="built_in">begin</span>(), cnt.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    std::<span class="built_in">fill</span>(tag.<span class="built_in">begin</span>(), tag.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [fr, to, val, z] : R[i]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = fr; j &lt;= to; ++j) &#123;</span><br><span class="line">                ans[z] += val * (cnt[a[j]] + tag[id[a[j]]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">addr</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        ans[Q[i][<span class="number">2</span>]] += ans[Q[i - <span class="number">1</span>][<span class="number">2</span>]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : ans) &#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
        <category>题解</category>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>莫队二次离线</tag>
      </tags>
  </entry>
</search>
